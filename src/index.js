export var tp;
import * as d3 from 'https://cdn.skypack.dev/d3-shape';
import {defOptions, defChannels, defShapeScheme} from './defaults.js';
(() => {
'use strict'; return _z_ = {
toUpperCase(e){return this._ew(e,(e=>String(e).toUpperCase()))},
toLowerCase(e){return this._ew(e,(e=>String(e).toLowerCase()))},
some(e,t){t=this._callback(t);let r=0;for(let n of e)if(t(n,r++,e))return!0;return!1},
empties(...e){return this._mdArray(e)},
string(e){return this._ew(e,String)},
attr(...e){return 2===e.length?this._apsGet(this._getAttr,...e):this._apsSet(this._setAttr,...e)},
addClass(e,t){return this._addRemoveClass(!0,e,t)},
number(e){return this._ew(e,Number)},
abs(e){return this._ew(e,Math.abs)},
round(e){return this._ew(e,Math.round)},
ceil(e){return this._ew(e,Math.ceil)},
floor(e){return this._ew(e,Math.floor)},
$path(e){return this._create(!0,"path",e)},
$g(e){return this._create(!0,"g",e)},
$defs(e){return this._create(!0,"defs",e)},
insert(e,t,r=(()=>null)){e=this._first(e),t="function"==typeof t?t.call(e,e.__data__):this._autoSelect(t),r=this._first(r.call(e,e.__data__));for(let n of t&&t[Symbol.iterator]?t:[t])e.insertBefore(n,r);return t},
$linearGradient(e){return this._create(!0,"linearGradient",e)},
*linSpace(e,t,r){if(1==(r=+r))yield(+e+ +t)/2;else{const n=(+t-+e)/(r-1);e=+e-n;for(let t=0;t<r;t++)yield e+=n}},
encodeSVG(e,t,r){return this._encode(!0,e,t,r)},
$rect(e){return this._create(!0,"rect",e)},
sketch({width:e=300,height:t=300,context:r="2d",scale:n=!0,...s}={}){let o=window.devicePixelRatio,i=document.createElement("canvas"),a=i.getContext(r,s);return n&&"2d"===r?(i.style.width=e+"px",i.style.height=t+"px",i.width=e*o,i.height=t*o,a.scale(o,o)):(i.width=e,i.height=t),[i,a]},
array(...e){const t=[];for(let r of e)if("string"!=typeof r&&r&&r[Symbol.iterator])for(let e of r)t.push(e);else t.push(r);return t},
pick(e,t){let r=[];for(let n of e)r.push(n[t]);return r},
reduce(e,t,r){let n=0;for(let s of e)r=t(r,s,n++,e);return r},
$text(e){return this._create(!0,"text",e)},
text(...e){return 1===e.length?this._apsGet(this._getProp,e[0],"textContent"):this._apsSet(this._setProp,e[0],"textContent",e[1])},
into(e,t,r=(()=>null)){t=this._first(t),"function"==typeof e?e=e.call(t,t.__data__):"string"==typeof e&&(e=document.querySelectorAll(e)),r=this._first(r.call(t,t.__data__));for(let n of e&&e[Symbol.iterator]?e:[e])t.insertBefore(n,r);return t},
sqrt(e){return this._ew(e,Math.sqrt)},
$line(e){return this._create(!0,"line",e)},
max(e,t){return this._minMax(!0,e,this._callback(t))},
$svg(e){return this._create(!0,"svg",e)},
style(...e){return 2===e.length?this._apsGet(this._getStyle,...e):this._apsSet(this._setStyle,...e)},
$clipPath(e){return this._create(!0,"clipPath",e)},
boolean(e){return this._ew(e,Boolean)},
$polygon(e){return this._create(!0,"polygon",e)},
select(...e){return 1===e.length?document.querySelector(e[0]):this._first(e[0]).querySelector(e[1])},
trim(e){return this._ew(e,(e=>String(e).trim()))},
intersection(e,...t){e=new Set(e),t=t.map((e=>e instanceof Set?e:new Set(e)));e:for(let r of e)for(let n of t)if(!n.has(r)){e.delete(r);continue e}return e},
filter(e,t){t=this._callback(t);let r=[],n=0;for(let s of e)t(s,n++,e)&&r.push(s);return r},
group(e,t,r){return this._group(!1,e,this._callback(t),r)},
selectAll(...e){return 1===e.length?[...document.querySelectorAll(e[0])]:[...this._first(e[0]).querySelectorAll(e[1])]},
at(...e){return this._at(...e)},
chg(e,t,r){return e[t]=r,e},
_ew(e,t){let r;if("string"!=typeof e&&e&&e[Symbol.iterator]){r=[];for(let n of e)r.push(t(n))}else r=t(e);return r},
_callback(e=(e=>e)){return"function"==typeof e?e:t=>t[e]},
_mdArray(e,t){return function r(n){const s=new Array(+e[n]);if(n===e.length-1)void 0!==t&&s.fill(t);else for(let t=0;t<+e[n];t++)s[t]=r(n+1);return s}(0)},
_apsGet(e,t,r){let n;if("string"==typeof t&&(t=document.querySelectorAll(t)),t&&t[Symbol.iterator]){n=[];for(let s of t)n.push(e(s,r))}else n=e(t,r);return n},
_apsSet(e,t,r,n){let s=0;t=this._autoSelect(t);for(let o of t&&t[Symbol.iterator]?t:[t])e(o,r,"function"==typeof n?n.call(o,o.__data__,s++):n);return t},
_getAttr(e,t){return e.getAttribute(t)},
_setAttr(e,t,r){e.setAttribute(t,r)},
_autoSelect(e){return"string"==typeof e?[...document.querySelectorAll(e)]:e},
_addRemoveClass(e,t,r){if(e=e?"add":"remove",r=r.trim().split(/^|\s+/),(t=this._autoSelect(t))&&t[Symbol.iterator])for(let n of t)n.classList[e](...r);else t.classList[e](...r);return t},
_create(e,t,r){let n;if(void 0===r)n=this._createElm(e,t);else{n=[];for(let s=0;s<r;s++)n.push(this._createElm(e,t))}return n},
_createElm(e,t){return e?document.createElementNS("http://www.w3.org/2000/svg",t):document.createElement(t)},
_first(e){return"string"==typeof e?document.querySelector(e):e&&e[Symbol.iterator]?e[Symbol.iterator]().next().value:e},
_encode(e,t,r,n=!0){let s=[];for(let o of t){let t=e?document.createElementNS("http://www.w3.org/2000/svg",r):document.createElement(r);n&&(t.__data__=o),s.push(t)}return s},
_getProp(e,t){return e[t]},
_setProp(e,t,r){e[t]=r},
_minMax(e,t,r){let n,s=NaN,o=0,i=e?(e,t)=>e<=t:(e,t)=>e>=t;for(let e of t){let a=+r(e,o++,t);if(isNaN(a))return;i(a,s)||(s=a,n=e)}return n},
_getStyle(e,t){return window.getComputedStyle(e).getPropertyValue(t)},
_setStyle(e,t,r){e.style.setProperty(t,r)},
_group(e,t,r,n){let s=new Map,o=0;for(let n of t){let i=r(n,o++,t);e?s.set(i,s.has(i)?s.get(i)+1:1):s.has(i)?s.get(i).push(n):s.set(i,[n])}if(void 0!==n)for(let[e,t]of s)s.set(e,n(t,e));return s},
_at(e,t,r){let n;if(r||Array.isArray(e)){n=[];for(let r of t)n.push(e[r])}else if("string"==typeof e){n="";for(let r of t)n+=e[r]}else{n={};for(let r of t)n[r]=e[r]}return n},
},
(void 0), (void 0), (void 0), clipCount = 0, gradientCount = 0, markNames = (new Set(['hBar','vBar','point','rect','segment','hLink','vLink','arc','edge','text','line','hBand','vBand'])), singleMarkNames = (new Set(['line','hBand','vBand'])), channelNames = (new (Set)((defChannels["keys"]()))), nonUpdateChannelNames = (new Set(['xOffset','yOffset','class','name','attach','note','noteColor','noteOpacity','noteXOffset','noteYOffset','noteClass','noteName','noteAttach'])), getKind = (function(ch) {return defChannels["get"](ch)['_kind']; }), xyChannelNames = (new Set(['x','xx','y','yy'])), legendFillStrokeChannels = (new Set(['fill','fillOpacity','stroke','strokeOpacity','strokeWidth','strokeDash'])), angleChannels = (new Set(['startAngle','endAngle','padAngle'])), curveTypes = (new Set(['basis','basisOpen','bundle','cardinal','cardinalOpen','catmullRom','catmullRomOpen','linear','monotoneX','monotoneY','natural','curveStep','curveStepAfter','curveStepBefore','basisClosed','cardinalClosed','catmullRomClosed','linearClosed'])), convenienceEvents = ['click','mouseenter','mouseleave'], markChannelError = (function(a,b,c) {return (e => {throw e})(Error(((((('mark-'+a)+', channel-')+b)+', ')+c))); }), isInfOrNaN = (function(val) {return ((Number.isNaN(val)||((val===Infinity)))||((val===((-Infinity))))); }), nonFiniteMsg = 'non-finite data value (NaN, Infinity or -Infinity)', allMissingMsg = 'every datum has a missing value', capitalize = (function(s) {return (_z_.toUpperCase((s["0"]))+(s["slice"](1))); }), camelToKebab = (function(s) {return s["replace"](/[A-Z]/g,(function(a,b,c) {return ('-'+(_z_.toLowerCase(a))); })); }), minVal = (function(arr) {return mn = Infinity, (_z_x => {for (let v of _z_x) {((((((v!==null))&&((v!==undefined)))&&((v<mn))))?(mn = v):void 0)} return _z_x})(arr), mn; var mn}), maxVal = (function(arr) {return mx = (-Infinity), (_z_x => {for (let v of _z_x) {((((((v!==null))&&((v!==undefined)))&&((v>mx))))?(mx = v):void 0)} return _z_x})(arr), mx; var mx}), checkShapeScheme = (function(scheme,mk) {return ((((scheme!==defShapeScheme)&&(_z_.some(scheme,(function(a,b,c) {return (!defShapeScheme["includes"](a)); })))))?((e => {throw e})(Error((('mark-'+(mk["type"]))+', invalid shape name')))):void 0), scheme; }), checkArrayOfObjects = (function(d) {return ((((!Array.isArray(d))||(_z_.some(d,(function(a,b,c) {return (((typeof a)!=='object')||((a===null))); })))))?((e => {throw e})(Error('array of objects/arrays expected'))):void 0); }), checkData = (function(arr,mk,ch) {return ((((arr["length"])===0))?(markChannelError((mk["type"]),ch,'empty data array')):void 0), ((_z_.some(arr,isInfOrNaN))?(markChannelError((mk["type"]),ch,nonFiniteMsg)):void 0), ((((((mk["missing"])==='skip'))||(((mk["missing"])==='gap'))))?(missingInds = (new Set([])), ((_z_l) => {for (let _z_i = 0; _z_i < _z_l; _z_i++) {let i = _z_i; (((((arr[i]) ?? null) === null))?(missingInds["add"](i)):void 0)}})((arr["length"])), ((((missingInds["size"])===(arr["length"])))?(markChannelError((mk["type"]),ch,allMissingMsg)):void 0)):true?(((_z_.some(arr,(function(a,b,c) {return ((a ?? null) === null); })))?(markChannelError((mk["type"]),ch,'missing data value')):void 0)):void 0), ((o,v1) => {o.missingInds=v1;return o})(({"data":arr,}),missingInds); var missingInds}), getChannelDefault = (function(mk,ch) {return obj = defChannels["get"](ch), (obj["hasOwnProperty"]((mk["type"]))?(obj[(mk["type"])]):(obj["def"])); var obj}), fourOption = (function(_options,opName) {return ((passed) => {return def = (defOptions[opName]), ((Array.isArray(passed))?((_z_x => {let _z_i = -1; for (let e of _z_x) {let arr = _z_x; let i = ++_z_i; (arr[i]) = ((passed[i])??def)} return _z_x})(_z_.empties(4))):true?(_z_.empties(4)["fill"](((passed??def)))):void 0); var def})((_options[opName])); }), populateDataMap = (function(dMap,ch,orderOp,seqOp) {return (((!((orderOp ?? null) === null)))?((((!Array.isArray(orderOp)))?((e => {throw e})(Error((ch+'Order is not an array')))):void 0), ((_z_.some(orderOp,(function(a,b,c) {return ((typeof a)==='number'); })))?((e => {throw e})(Error((ch+'Order contains a number')))):void 0), ((_z_.some(orderOp,(function(a,b,c) {return ((a ?? null) === null); })))?((e => {throw e})(Error((ch+'Order contains a null or undefined value')))):void 0), ((((new (Set)(orderOp))['size']<(orderOp["length"])))?((e => {throw e})(Error((ch+'Order contains a duplicate')))):void 0), (_z_x => {for (let val of _z_x) {dMap["set"](val,(dMap["size"]))} return _z_x})(orderOp)):((!((seqOp ?? null) === null)))?(((((!Number.isInteger(seqOp))||((seqOp<=0))))?((e => {throw e})(Error((ch+'Seq must be a positive integer')))):void 0), j = 0, (() => {let _z_s; while (1) {(((j<seqOp))?(dMap["set"]((_z_.string(j)),j), j += 1):true?((_z_s = 1, void 0)):void 0); if (_z_s) break}})()):void 0); var j}), updateDataMap = (function(dataMap,key) {return ((((typeof key)==='number'))?(key):(dataMap["has"](key))?(dataMap["get"](key)):true?(sz = (dataMap["size"]), dataMap["set"](key,sz), sz):void 0); var sz}), setUnlessNullish = (function(elm,attrName,val) {return (((!((val ?? null) === null)))?(_z_.attr(elm,attrName,val)):void 0), elm; }), finishMark = (function(elm,mk,channels,i,isSubplot) {return (((!isSubplot))?(setUnlessNullish(setUnlessNullish(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.attr(elm,'fill',(channels["fill"](i))),'fill-opacity',(channels["fillOpacity"](i))),'stroke',(channels["stroke"](i))),'stroke-opacity',(channels["strokeOpacity"](i))),'stroke-width',(channels["strokeWidth"](i))),'stroke-linecap',(channels["strokeCap"](i))),'stroke-dasharray',(channels["strokeDash"](i)))):void 0), c = channels['class'](i), (((!((c ?? null) === null)))?(_z_.addClass(elm,c)):void 0), nm = channels["name"](i), (((!((nm ?? null) === null)))?(_z_.attr(elm,'data-tp-name',nm)):void 0), d = channels['attach'](i), (((!((d ?? null) === null)))?((elm["__data__"]) = d):void 0), (_z_x => {for (let eventType of _z_x) {(((!(((mk[eventType]) ?? null) === null)))?(elm["addEventListener"](eventType,(mk[eventType]))):void 0)} return _z_x})(convenienceEvents), (((!(((mk["callback"]) ?? null) === null)))?(mk["callback"](elm,i,nm)):void 0); var c,nm,d}), finishNote = (function(elm,channels,i) {return c = channels['noteClass'](i), (((!((c ?? null) === null)))?(_z_.addClass(elm,c)):void 0), nm = channels["noteName"](i), (((!((nm ?? null) === null)))?(_z_.attr(elm,'data-tp-name',nm)):void 0), d = channels["noteAttach"](i), (((!((d ?? null) === null)))?((elm["__data__"]) = d):void 0); var c,nm,d}), useColorScheme = (function(data,scheme,mk,ch) {return isConst = (!Array.isArray(data)), ((((typeof scheme)==='function'))?([mn,mx,] = (mk[((ch+'Limits'))]??([null,null])), mn = _z_.number((mn??((isConst?data:(minVal(data)))))), mx = _z_.number((mx??((isConst?data:(maxVal(data)))))), (((!(Number.isFinite(mn)&&(Number.isFinite(mx)))))?(markChannelError((mk["type"]),ch,((ch+' limits are not finite')))):void 0), ((((mx-mn)<1e-14))?(markChannelError((mk["type"]),ch,((ch+' limits are equal or the wrong way round')))):void 0), (isConst?(data = scheme(((data-mn)/((mx-mn))))):true?(rng = (mx-mn), ((_z_l) => {for (let _z_i = 0; _z_i < _z_l; _z_i++) {let i = _z_i; (data[i]) = scheme((((data[i])-mn)/rng))}})((data["length"]))):void 0), info = ((o,v1) => {o.scheme=v1;return o})(({'min':mn,'max':mx,}),scheme)):true?((isConst?(data = (scheme[data])):true?(((_z_l) => {for (let _z_i = 0; _z_i < _z_l; _z_i++) {let i = _z_i; (data[i]) = scheme[(data[i])]}})((data["length"]))):void 0), info = ((o,v1) => {o.scheme=v1;return o})(({}),scheme)):void 0), ((o,v1,v2) => {o.data=v1;o.info=v2;return o})(({}),data,info); var isConst,mn,mx,rng,info}), equalTo = (function(u,v) {return (_z_.abs((u-v))<1e-14); }), magnitude = (function(v) {return sf = v["toExponential"](), _z_.number(sf["slice"](((sf["indexOf"]('e')+1)))); var sf}), magnitude10 = (function(v) {return m = magnitude(v), (equalTo((10**m),v)?((m-1)):m); var m}), roundToMagnitude = (function(v,mag,upDown) {return magVal = (10**mag), v = (v/magVal), r = _z_.round(v), v = ((equalTo(v,r))?(r):((upDown==='up'))?(_z_.ceil(v)):((upDown==='down'))?(_z_.floor(v)):true?(r):void 0), enforceRound((v*magVal),mag); var magVal,r}), enforceRound = (function(v,mag) {return ((mag<0)?(_z_.number(v["toFixed"]((_z_.abs(mag))))):v); }), accuracy = (function(t) {return m = magnitude(t), s = 1, (() => {let _z_s; while (1) {((equalTo(_z_.number(t["toPrecision"](s)),t))?((_z_s = 1, void 0)):((s===14))?((e => {throw e})(Error('failed to compute accuracy'))):true?(s += 1):void 0); if (_z_s) break}})(), ((m-s)+1); var m,s}), getTextWidth = (function(ctx,txt) {return ctx["measureText"](txt)['width']; }), shapeDetails = ({'circle':(({"name":'Circle',"xMult":1.138,"yMult":1.138,})),'square':(({"name":'Square',"xMult":1,"yMult":1,})),'diamond':(({"name":'Square',"xMult":1.414,"yMult":1.414,"rotate":45,})),'star':(({"name":'Star',"xMult":1.777,"yMult":1.777,})),'wye':(({"name":'Wye',"xMult":1.469,"yMult":1.469,})),'triangle-up':(({"name":'Triangle',"xMult":1.477,"yMult":1.3,"yShift":0.2,})),'triangle-down':(({"name":'Triangle',"xMult":1.477,"yMult":1.3,"yShift":((-0.2)),"rotate":180,})),'triangle-right':(({"name":'Triangle',"xMult":1.3,"yMult":1.477,"xShift":((-0.15)),"rotate":90,})),'triangle-left':(({"name":'Triangle',"xMult":1.3,"yMult":1.477,"xShift":0.15,"rotate":270,})),"plus":(({"name":'Cross',"xMult":1.331,"yMult":1.331,})),"times":(({"name":'Cross',"xMult":1.254,"yMult":1.254,"rotate":45,})),}), pointSymbol = (function(ops={}) {return ({path,shape,area,x,y,} = ops), ({name,rotate,} = (shapeDetails[shape])), tform = (((('translate('+x)+' ')+y)+')'), (rotate?(tform += ((' rotate('+rotate)+')')):void 0), _z_.attr(_z_.attr((path??(_z_.$path())),'d',(d3["symbol"]((d3[(('symbol'+name))]),area)())),'transform',tform); var path,shape,area,x,y,name,rotate,tform}), polygonCentroid = (function(p) {return i = (-1), n = (p["length"]), x = 0, y = 0, a = null, b = p[((n-1))], c = null, k = 0, (() => {let _z_s; while (1) {i += 1, (((i<n))?(a = b, b = (p[i]), c = (((a["0"])*(b["1"]))-(((b["0"])*(a["1"])))), k += c, x += (((a["0"])+(b["0"]))*c), y += (((a["1"])+(b["1"]))*c)):true?((_z_s = 1, void 0)):void 0); if (_z_s) break}})(), k *= 3, [((x/k)),((y/k))]; var i,n,x,y,a,b,c,k}), colorRamp = (function(schemeFun,width,height) {return f = (function(v) {return schemeFun((1-v)); }), id = ('legend-gradient-'+gradientCount), gradientCount += 1, g = _z_.$g(), _z_.attr(_z_.attr(_z_.insert(_z_.attr(_z_.attr(_z_.insert(_z_.insert(g,(_z_.$defs())),(_z_.$linearGradient())),'id',id),'gradientTransform','rotate(90)'),(_z_.encodeSVG(_z_.linSpace(0,1,16),'stop'))),'offset',(function(a,b,c) {return ((a*100)+'%'); })),'stop-color',f), _z_.attr(_z_.attr(_z_.attr(_z_.insert(g,(_z_.$rect())),'width',width),'height',height),'fill',((('url(#'+id)+')'))), g; var f,id,g}), tp = (class {constructor() {(this["_marks"]) = [], (this["_dataset"]) = null, (this["_options"]) = ({}); }}), tp["prototype"]['plot'] = (function(target) {return ({_marks,_dataset,_options,} = this), ((((_marks["length"])===0))?((e => {throw e})(Error('plot has no marks'))):void 0), op = (function(a,b,c) {return ((_options[a])??(defOptions[a])); }), setAttr = (function(a,b,c) {return _z_.attr(a,b,(op(c))); }), setDimAttr = (function(elm,dim,attrName,opName) {return _z_.attr(elm,attrName,((op((dim+(capitalize(opName))))??(op(opName))))); }), setFont = (function(elm,prefix) {return _z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.attr(elm,'font-family',((op((prefix+'FontFamily'))??(op('fontFamily'))))),'font-size',(((op((prefix+'FontSize'))??(op('fontSize')))+'px'))),'font-style',((op((prefix+'FontStyle'))??(op('fontStyle'))))),'font-weight',((op((prefix+'FontWeight'))??(op('fontWeight'))))),'fill',((op((prefix+'Color'))??(op('color'))))),'fill-opacity',((op((prefix+'Opacity'))??(op('opacity'))))),'stroke-width',0); }), getCanvasContext = (function(prefix) {return [canvas,ctx,] = _z_.sketch(), (ctx["font"]) = (((((((''+((op((prefix+'FontStyle'))??(op('fontStyle')))))+' ')+((op((prefix+'FontWeight'))??(op('fontWeight')))))+' ')+(((op((prefix+'FontSize'))??(op('fontSize')))+'px')))+' ')+((op((prefix+'FontFamily'))??(op('fontFamily'))))), ctx; var canvas,ctx}), channelData = (function(mk,ch) {return data = (mk[ch]), ((((data ?? null) === null))?(({"isConst":true,"data":(getChannelDefault(mk,ch)),})):(Array.isArray(data))?(checkData(_z_.array(data),mk,ch)):((((((typeof data)==='string')&&(((data["0"])==='~'))))||(((typeof data)==='function'))))?(ds = ((mk["data"])??_dataset), (((!ds))?(markChannelError((mk["type"]),ch,('no dataset attached to mark or plot'))):void 0), checkData(((((typeof data)==='function'))?(ds['map'](data)):true?(_z_.pick(ds,(data["slice"](1)))):void 0),mk,ch)):true?(((isInfOrNaN(data))?(markChannelError((mk["type"]),ch,nonFiniteMsg)):void 0), ((o,v1) => {o.data=v1;return o})(({"isConst":true,}),data)):void 0); var data,ds}), dataMaps = ({"x":((new Map([]))),"y":((new Map([]))),"fill":((new Map([]))),"stroke":((new Map([]))),"shape":((new Map([]))),}), (_z_x => {for (let dim of _z_x) {populateDataMap((dataMaps[dim]),dim,(op((dim+'Order'))),(op((dim+'Seq'))))} return _z_x})('xy'), limitsOp = op('limits'), ((Array.isArray(limitsOp))?(((((limitsOp["length"])<4))?(limitsOp = _z_.array(limitsOp), (limitsOp["length"]) = 4):void 0), [xMinOp,xMaxOp,yMinOp,yMaxOp,] = ((u, v) => {let r = []; for (let s of u) r.push(s ?? v); return r})(limitsOp,(defOptions["limits"]))):true?(xMinOp = limitsOp, xMaxOp = limitsOp, yMinOp = limitsOp, yMaxOp = limitsOp):void 0), xMin = ((((xMinOp==='_nice')||((xMinOp==='_data'))))?Infinity:xMinOp), xMax = ((((xMaxOp==='_nice')||((xMaxOp==='_data'))))?((-Infinity)):xMaxOp), yMin = ((((yMinOp==='_nice')||((yMinOp==='_data'))))?Infinity:yMinOp), yMax = ((((yMaxOp==='_nice')||((yMaxOp==='_data'))))?((-Infinity)):yMaxOp), xMinReqd = (xMin===Infinity), xMaxReqd = (xMax===((-Infinity))), yMinReqd = (yMin===Infinity), yMaxReqd = (yMax===((-Infinity))), markChannels = (new Map([])), markObs = (new Map([])), markSchemes = (new Map([])), markAreaInfo = (new Map([])), markPresentInds = (new Map([])), (_z_x => {for (let mk of _z_x) {let type,channels,nObs,schemeInfo,missingAll,channelsList,noteUsed,pieUsed,presentInds; ({type,} = mk), channels = ({}), nObs = null, schemeInfo = ({}), missingAll = (new Set([])), channelsList = (new Set([])), noteUsed = (!(((mk["note"]) ?? null) === null)), pieUsed = (!(((mk["pie"]) ?? null) === null)), (_z_x => {for (let ch of _z_x) {let kind,data,missingInds,isConst; kind = getKind(ch), ((((((kind==='common')||(((type==='text')&&((kind==='text')))))||((((type!=='text')&&noteUsed)&&(((kind==='text')||((kind==='note')))))))||((((kind==='special')&&(defChannels["get"](ch)["hasOwnProperty"](type)))&&((!((!pieUsed)&&((ch==='pie')))))))))?(channelsList["add"](ch), ({data,missingInds,isConst,} = channelData(mk,ch)), ((((singleMarkNames["has"](type)&&((!xyChannelNames["has"](ch))))&&((!isConst))))?(markChannelError(type,ch,'data must be constant')):void 0), ((((pieUsed&&(angleChannels["has"](ch)))&&((!isConst))))?(markChannelError(type,ch,('data must be constant when used with pie channel'))):void 0), (missingInds?((_z_x => {for (let i of _z_x) {missingAll["add"](i)} return _z_x})(missingInds)):void 0), (((!isConst))?((((nObs===null))?(nObs = (data["length"])):(((data["length"])!==nObs))?(markChannelError(type,ch,('length of data not consistent with other channels'))):void 0)):void 0), (channels[ch]) = data):void 0)} return _z_x})(channelNames), (((nObs===null))?(nObs = 1):void 0), presentInds = (new Set([])), ((_z_l) => {for (let _z_i = 0; _z_i < _z_l; _z_i++) {let i = _z_i; presentInds["add"](i)}})(nObs), (_z_x => {for (let i of _z_x) {presentInds['delete'](i)} return _z_x})(missingAll), ((((presentInds["size"])===0))?((e => {throw e})(Error(((('mark-'+type)+', ')+allMissingMsg)))):void 0), (_z_x => {for (let ch of _z_x) {let data,isConst,scheme,dataMap; data = (channels[ch]), isConst = (!Array.isArray(data)), ((((((xyChannelNames["has"](ch))||((ch==='fill')))||((ch==='stroke')))||((ch==='shape'))))?(scheme = mk[((ch+'Scheme'))], ((xyChannelNames["has"](ch))?(dataMap = dataMaps[(ch["0"])]):true?(dataMap = null, (((typeof scheme === 'string'))?(scheme = [scheme]):void 0), (() => {return ((((ch==='shape')||(((!((scheme ?? null) === null))&&(((typeof scheme)!=='function'))))))?(dataMap = (new Map([])), populateDataMap(dataMap,ch,(mk[((ch+'Order'))]),(mk[((ch+'Seq'))])), (dataMaps[ch])["set"](mk,dataMap)):void 0); })()):void 0), (dataMap?((isConst?(data = updateDataMap(dataMap,data)):true?((_z_x => {let _z_i = -1; for (let v of _z_x) {let i = ++_z_i; ((presentInds["has"](i))?((data[i]) = updateDataMap(dataMap,v)):void 0)} return _z_x})(data)):void 0)):void 0), ((((ch==='fill')||((ch==='stroke'))))?((() => {return (((!((scheme ?? null) === null)))?(actualColors = useColorScheme(data,scheme,mk,ch), data = (actualColors["data"]), (schemeInfo[ch]) = (actualColors["info"])):void 0); var actualColors})()):((ch==='shape'))?(((s) => {return (isConst?(data = (s[data])):true?(((_z_l) => {for (let _z_i = 0; _z_i < _z_l; _z_i++) {let i = _z_i; (data[i]) = s[(data[i])]}})((data["length"]))):void 0), (schemeInfo["shape"]) = ({"scheme":s,}); })(checkShapeScheme((scheme??defShapeScheme),mk))):void 0)):void 0), (channels[ch]) = (isConst?((function() {return data; })):((function(i) {return (data[i]); })))} return _z_x})(channelsList), (() => {return xMinNeed = xMinReqd, xMaxNeed = xMaxReqd, yMinNeed = yMinReqd, yMaxNeed = yMaxReqd, ({x,y,xx,yy,size,} = channels), ((dataMaps["x"]["size"])?((xMinNeed?(xMin = ((x, y) => y < x ? y : x)(xMin,0)):void 0), (xMaxNeed?(xMax = ((x, y) => y > x ? y : x)(xMax,(((dataMaps["x"]["size"])-1)))):void 0)):void 0), ((dataMaps["y"]["size"])?((yMinNeed?(yMin = ((x, y) => y < x ? y : x)(yMin,0)):void 0), (yMaxNeed?(yMax = ((x, y) => y > x ? y : x)(yMax,(((dataMaps["y"]["size"])-1)))):void 0)):void 0), ((((type==='rect')&&((!(mk["pixels"])))))?(w = (channels["width"]), h = (channels["height"]), corner = (mk["corner"]), ((xMinNeed)?((_z_x => {for (let i of _z_x) {xMin = ((x, y) => y < x ? y : x)(xMin,((corner?(x(i)):((x(i)-((w(i)/2)))))))} return _z_x})(presentInds), xMinNeed = false):void 0), ((xMaxNeed)?((_z_x => {for (let i of _z_x) {xMax = ((x, y) => y > x ? y : x)(xMax,((x(i)+((w(i)/((corner?1:2)))))))} return _z_x})(presentInds), xMaxNeed = false):void 0), ((yMinNeed)?((_z_x => {for (let i of _z_x) {yMin = ((x, y) => y < x ? y : x)(yMin,((corner?(y(i)):((y(i)-((h(i)/2)))))))} return _z_x})(presentInds), yMinNeed = false):void 0), ((yMaxNeed)?((_z_x => {for (let i of _z_x) {yMax = ((x, y) => y > x ? y : x)(yMax,((y(i)+((h(i)/((corner?1:2)))))))} return _z_x})(presentInds), yMaxNeed = false):void 0)):((type==='vBar'))?(((xMinNeed)?((_z_x => {for (let i of _z_x) {xMin = ((x, y) => y < x ? y : x)(xMin,((x(i)-((size(i)/2)))))} return _z_x})(presentInds), xMinNeed = false):void 0), ((xMaxNeed)?((_z_x => {for (let i of _z_x) {xMax = ((x, y) => y > x ? y : x)(xMax,((x(i)+((size(i)/2)))))} return _z_x})(presentInds), xMaxNeed = false):void 0)):((type==='hBar'))?(((yMinNeed)?((_z_x => {for (let i of _z_x) {yMin = ((x, y) => y < x ? y : x)(yMin,((y(i)-((size(i)/2)))))} return _z_x})(presentInds), yMinNeed = false):void 0), ((yMaxNeed)?((_z_x => {for (let i of _z_x) {yMax = ((x, y) => y > x ? y : x)(yMax,((y(i)+((size(i)/2)))))} return _z_x})(presentInds), yMaxNeed = false):void 0)):void 0), (xMinNeed?((_z_x => {for (let i of _z_x) {xMin = ((x, y) => y < x ? y : x)(xMin,(x(i)))} return _z_x})(presentInds), (xx?((_z_x => {for (let i of _z_x) {xMin = ((x, y) => y < x ? y : x)(xMin,(xx(i)))} return _z_x})(presentInds)):void 0)):void 0), (xMaxNeed?((_z_x => {for (let i of _z_x) {xMax = ((x, y) => y > x ? y : x)(xMax,(x(i)))} return _z_x})(presentInds), (xx?((_z_x => {for (let i of _z_x) {xMax = ((x, y) => y > x ? y : x)(xMax,(xx(i)))} return _z_x})(presentInds)):void 0)):void 0), (yMinNeed?((_z_x => {for (let i of _z_x) {yMin = ((x, y) => y < x ? y : x)(yMin,(y(i)))} return _z_x})(presentInds), (yy?((_z_x => {for (let i of _z_x) {yMin = ((x, y) => y < x ? y : x)(yMin,(yy(i)))} return _z_x})(presentInds)):void 0)):void 0), (yMaxNeed?((_z_x => {for (let i of _z_x) {yMax = ((x, y) => y > x ? y : x)(yMax,(y(i)))} return _z_x})(presentInds), (yy?((_z_x => {for (let i of _z_x) {yMax = ((x, y) => y > x ? y : x)(yMax,(yy(i)))} return _z_x})(presentInds)):void 0)):void 0); var xMinNeed,xMaxNeed,yMinNeed,yMaxNeed,x,y,xx,yy,size,w,h,corner})(), (((type==='point'))?(markAreaInfo["set"](mk,((() => {return mn = _z_.reduce(presentInds,(function(a,b,c) {return ((x, y) => y < x ? y : x)(a,(channels["area"](b))); }),Infinity), mx = _z_.reduce(presentInds,(function(a,b,c) {return ((x, y) => y > x ? y : x)(a,(channels["area"](b))); }),((-Infinity))), ({'min':mn,'max':mx,"scale":((((((mk["areaScale"]) ?? null) === null))?((function(a,b,c) {return a; })):((typeof (mk["areaScale"]) === 'function'))?((function(val) {return mk["areaScale"](val,mn,mx); })):((typeof (mk["areaScale"]) === 'number'))?((function(a,b,c) {return ((a/mx)*(mk["areaScale"])); })):true?((e => {throw e})(Error('mark-point, areaScale must be a number or function'))):void 0)),}); var mn,mx})()))):void 0), markChannels["set"](mk,channels), markObs["set"](mk,nObs), markSchemes["set"](mk,schemeInfo), markPresentInds["set"](mk,presentInds)} return _z_x})(_marks), gLegend = _z_.$g(), legendWidth = 0, legendHeight = 0, legendPosition = op('legendPosition'), legendOut = (legendPosition["slice"](0,3)==='out'), legendGap = op('legendGap'), ((op('legend'))?((() => {return symbolSize = 10, rampHeight = op('legendRampHeight'), rampWidth = 15, pointSize = 64, legendPadding = fourOption(_options,'legendPadding'), hGap = op('legendLabelPadding'), vGap = (1.5*hGap), legendRect = setUnlessNullish(setAttr(setAttr(setAttr(setAttr(_z_.insert(gLegend,(_z_.$rect())),'fill','legendBackground'),'fill-opacity','legendBackgroundOpacity'),'stroke','legendBorderColor'),'stroke-width','legendBorderWidth'),'rx',(op('legendCornerRadius'))), gContent = setFont(_z_.attr(_z_.attr(_z_.attr(_z_.insert(gLegend,(_z_.$g())),'text-anchor','start'),'dominant-baseline','middle'),'transform',(((((('translate('+(legendPadding["3"]))+' ')+(legendPadding["0"]))+')')))),'legendLabel'), titleFontSize = (op('legendTitleFontSize')??(op('fontSize'))), labelFontSize = (op('legendLabelFontSize')??(op('fontSize'))), titleCtx = getCanvasContext('legendTitle'), labelCtx = getCanvasContext('legendLabel'), contentHeight = 0, contentWidth = 0, (_z_x => {for (let mk of _z_x) {let type,channels,chConst,setConstant; ({type,} = mk), channels = markChannels["get"](mk), chConst = ({}), (_z_x => {for (let ch of _z_x) {(chConst[ch]) = ((channels[ch]["length"])?(getChannelDefault(mk,ch)):(channels[(ch)]()))} return _z_x})(legendFillStrokeChannels), setConstant = (function(elm,chs) {return (_z_x => {for (let ch of _z_x) {let attrName; attrName = camelToKebab(ch), (((ch==='strokeDash'))?(attrName += 'array'):void 0), _z_.attr(elm,attrName,(chConst[ch]))} return _z_x})((chs??legendFillStrokeChannels)), elm; }), (_z_x => {for (let ch of _z_x) {let opValue,chFormat,chSchemeInfo,chScheme,titleValue,addLabel; opValue = mk[((ch+'Legend'))], chFormat = (mk[((ch+'Format'))]??(function(a,b,c) {return a; })), chSchemeInfo = markSchemes["get"](mk)?.[ch], chScheme = chSchemeInfo?.['scheme'], (((((opValue===true)||(((opValue!==false)&&(channels[ch]["length"]))))&&((((ch==='shape')||((ch==='area')))||chScheme))))?(titleValue = mk[((ch+'Title'))], (((!((titleValue ?? null) === null)))?(contentHeight += (((contentHeight?((1.5*vGap)):0)+((titleFontSize/2)))), contentWidth = ((x, y) => y > x ? y : x)(contentWidth,(getTextWidth(titleCtx,titleValue))), setFont(_z_.text(_z_.attr(_z_.insert(gContent,(_z_.$text())),'y',contentHeight),titleValue),'legendTitle'), contentHeight += (titleFontSize/2)):void 0), addLabel = (function(nameInt,symbolWidth,central) {return symbolWidth = symbolWidth ?? (symbolSize), lbl = chFormat(...nameInt), elm = _z_.attr(_z_.attr(_z_.text(_z_.$text(),lbl),'x',((symbolWidth+hGap))),'y',contentHeight), (central?(_z_.attr(elm,'dominant-baseline','central')):void 0), _z_.into(elm,gContent), contentWidth = ((x, y) => y > x ? y : x)(contentWidth,(((symbolWidth+hGap)+(getTextWidth(labelCtx,lbl))))); var lbl,elm}), ((((ch==='fill')||((ch==='stroke'))))?((() => {return ((Array.isArray(chScheme))?((_z_x => {for (let nameInt of _z_x) {let pointElm; contentHeight += ((contentHeight?vGap:0)+((labelFontSize/2))), pointElm = null, (((type==='point'))?(pointElm = pointSymbol((({"shape":(((channels["shape"]["length"])?'circle':(channels["shape"]()))),"area":pointSize,"x":((_z_.sqrt(pointSize)/2)),"y":contentHeight,})))):void 0), _z_.into((((ch==='stroke'))?(_z_.attr(setConstant(_z_.attr((pointElm||(_z_.attr(_z_.attr(_z_.attr(_z_.$line(),'x2',symbolSize),'y1',contentHeight),'y2',contentHeight))),'stroke',(chScheme[(nameInt["1"])])),(['strokeOpacity','strokeWidth','strokeDash'])),'fill','none')):true?(_z_.attr(setConstant(_z_.attr((pointElm||(_z_.attr(_z_.attr(_z_.attr(_z_.$rect(),'y',((contentHeight-((symbolSize/2))))),'width',symbolSize),'height',symbolSize))),'fill',(chScheme[(nameInt["1"])])),(['fillOpacity'])),'stroke','none')):void 0),gContent), addLabel(nameInt), contentHeight += (labelFontSize/2)} return _z_x})((dataMaps[ch])["get"](mk))):((typeof chScheme === 'function'))?(contentHeight += (contentHeight?vGap:0), _z_.insert(gContent,(_z_.attr(_z_.attr(colorRamp(chScheme,rampWidth,rampHeight),'transform',((('translate(0 '+contentHeight)+')'))),'fill-opacity',(chConst["fillOpacity"])))), mn = chFormat(chSchemeInfo['min']), mx = chFormat(chSchemeInfo['max']), contentWidth = ((x, y) => y > x ? y : x)(contentWidth,(((rampWidth+hGap)+(((x, y) => y > x ? y : x)(getTextWidth(labelCtx,mn),(getTextWidth(labelCtx,mx))))))), _z_.text(_z_.attr(_z_.attr(_z_.attr(_z_.insert(gContent,(_z_.$text())),'dominant-baseline','hanging'),'x',((rampWidth+hGap))),'y',contentHeight),mx), contentHeight += rampHeight, _z_.text(_z_.attr(_z_.attr(_z_.attr(_z_.insert(gContent,(_z_.$text())),'dominant-baseline','auto'),'x',((rampWidth+hGap))),'y',contentHeight),mn)):void 0); var mn,mx})()):((ch==='shape'))?((_z_x => {for (let nameInt of _z_x) {contentHeight += ((contentHeight?vGap:0)+((labelFontSize/2))), _z_.into(setConstant(pointSymbol((({"shape":(chScheme[(nameInt["1"])]),"area":pointSize,"x":((_z_.sqrt(pointSize)/2)),"y":contentHeight,})))),gContent), addLabel(nameInt), contentHeight += (labelFontSize/2)} return _z_x})((dataMaps["shape"])["get"](mk))):((ch==='area'))?((() => {return areaInfo = markAreaInfo["get"](mk), mn = areaInfo['min'], mx = areaInfo['max'], ({scale,} = areaInfo), ticks = ((mk["areaTickValues"])??([mn,(((mn+mx)/2)),mx])), ((ticks["length"])?(shp = ((channels["shape"]["length"])?'circle':(channels["shape"]())), ({xMult,yMult,xShift,yShift,} = (shapeDetails[shp])), areas = ticks['map'](scale), hLengths = ((u, v) => {let r = []; for (let s of u) r.push(s * v); return r})(_z_.sqrt(areas),xMult), vLengths = ((u, v) => {let r = []; for (let s of u) r.push(s * v); return r})(_z_.sqrt(areas),yMult), hMax = _z_.max(hLengths), jumps = ((u, v) => {let r = []; for (let s of u) r.push(s / v); return r})(((u, v) => {let r = []; for (let s of u) r.push(v > s ? v : s); return r})(vLengths,labelFontSize),2), x = ((0.5+((xShift??0)))*hMax), (_z_x => {let _z_i = -1; for (let tick of _z_x) {let i = ++_z_i; (contentHeight?(contentHeight += vGap):void 0), contentHeight += (((jumps[((i-1))]??0))+(jumps[i])), _z_.into(setConstant(pointSymbol((({"shape":shp,"area":(areas[i]),"x":x,"y":((contentHeight+(((jumps[i])*((yShift??0)))))),})))),gContent), addLabel(([tick,i]),hMax,'central')} return _z_x})(ticks), contentHeight += jumps[(((ticks["length"])-1))]):void 0); var areaInfo,mn,mx,scale,ticks,shp,xMult,yMult,xShift,yShift,areas,hLengths,vLengths,hMax,jumps,x})()):void 0)):void 0)} return _z_x})(((type==='point')?(['fill','stroke','shape','area']):(['fill','stroke'])))} return _z_x})(_marks), (contentWidth?(legendWidth = ((contentWidth+(legendPadding["3"]))+(legendPadding["1"])), legendHeight = ((contentHeight+(legendPadding["0"]))+(legendPadding["2"])), _z_.attr(_z_.attr(legendRect,'width',legendWidth),'height',legendHeight)):void 0); var symbolSize,rampHeight,rampWidth,pointSize,legendPadding,hGap,vGap,legendRect,gContent,titleFontSize,labelFontSize,titleCtx,labelCtx,contentHeight,contentWidth})()):void 0), (((op('plot')===false))?(gLegend):true?((((!(Number.isFinite(xMin)&&(Number.isFinite(xMax)))))?((e => {throw e})(Error('x limits are not finite numbers'))):void 0), (((!(Number.isFinite(yMin)&&(Number.isFinite(yMax)))))?((e => {throw e})(Error('y limits are not finite numbers'))):void 0), ((((xMax-xMin)<1e-14))?((((((((xMin===0))&&((xMax===0)))&&((xMinOp==='_nice')))&&((xMaxOp==='_nice'))))?(xMin = (-1), xMax = 1):true?((e => {throw e})(Error('x limits are equal or the wrong way round'))):void 0)):void 0), ((((yMax-yMin)<1e-14))?((((((((yMin===0))&&((yMax===0)))&&((yMinOp==='_nice')))&&((yMaxOp==='_nice'))))?(yMin = (-1), yMax = 1):true?((e => {throw e})(Error('y limits are equal or the wrong way round'))):void 0)):void 0), xMag = magnitude10((xMax-xMin)), yMag = magnitude10((yMax-yMin)), (((xMinOp==='_nice'))?(xMin = ((dataMaps["x"]["size"])?((xMin-0.1)):(roundToMagnitude(xMin,xMag,'down')))):void 0), (((xMaxOp==='_nice'))?(xMax = ((dataMaps["x"]["size"])?((xMax+0.1)):(roundToMagnitude(xMax,xMag,'up')))):void 0), (((yMinOp==='_nice'))?(yMin = ((dataMaps["y"]["size"])?((yMin-0.1)):(roundToMagnitude(yMin,yMag,'down')))):void 0), (((yMaxOp==='_nice'))?(yMax = ((dataMaps["y"]["size"])?((yMax+0.1)):(roundToMagnitude(yMax,yMag,'up')))):void 0), xRange = (xMax-xMin), yRange = (yMax-yMin), xClean = (op('xClean')??(op('clean'))), yClean = (op('yClean')??(op('clean'))), usedDims = ((''+((xClean?'':'x')))+((yClean?'':'y'))), ticks = ({"x":([]),"y":([]),}), labels = ({"x":([]),"y":([]),}), (_z_x => {for (let dim of _z_x) {let dimTicks,dimMin,dimMax,dimIsCat,dimLabels,useLabels,fmt,addTick,nonNumericLookup,numericSet,tickValues,tickStep,tickStepMag,t; dimTicks = op((dim+'Ticks')), (((dimTicks||((op('ticks')&&(((dimTicks ?? null) === null))))))?([dimMin,dimMax,] = (((dim==='x'))?([xMin,xMax]):([yMin,yMax])), dimIsCat = (dataMaps[dim]["size"]), dimLabels = op((dim+'Labels')), (((dimLabels||((op('labels')&&(((dimLabels ?? null) === null))))))?(useLabels = true, fmt = (op((dim+'Format'))??(function(a,b,c) {return a; }))):void 0), addTick = ((dimIsCat?(nonNumericLookup = _z_.array((dataMaps[dim])["keys"]()), numericSet = (new (Set)(((dataMaps[dim])["values"]()))), (function(val) {return ((((typeof val)==='number'))?((((!numericSet["has"](val)))?((e => {throw e})(Error((dim+'-ticks, numeric tick value has no corresponding categorical value')))):void 0), (ticks[dim])["push"](val), (useLabels?((labels[dim])["push"]((fmt((nonNumericLookup[val]),val)))):void 0)):true?((((!(dataMaps[dim])["has"](val)))?((e => {throw e})(Error((dim+'-ticks, categorical tick value does not appear in the data')))):void 0), numVal = (dataMaps[dim])["get"](val), (ticks[dim])["push"](numVal), (useLabels?((labels[dim])["push"]((fmt(val,numVal)))):void 0)):void 0); var numVal})):true?((function(val) {return ((((typeof val)!=='number'))?((e => {throw e})(Error((dim+'-ticks, unexpected categorical (non-numeric) tick value')))):void 0), (ticks[dim])["push"](val), (useLabels?((labels[dim])["push"]((fmt(val)))):void 0); })):void 0)), ((((!dimIsCat)&&(op((dim+'TickMin')))))?(addTick(dimMin)):void 0), tickValues = op((dim+'TickValues')), (((!((tickValues ?? null) === null)))?((_z_x => {for (let v of _z_x) {addTick(v)} return _z_x})(tickValues)):true?(tickStep = op((dim+'TickStep')), (dimIsCat?(((((tickStep ?? null) === null))?(tickStep = 1):true?(tickStep = _z_.abs(_z_.number(tickStep)), ((((!Number.isInteger(tickStep))||((tickStep===0))))?((e => {throw e})(Error((('invalid '+dim)+'TickStep for categorical axis')))):void 0)):void 0), (_z_x => {for (let v of _z_x) {((((v%tickStep)===0))?(addTick(v)):void 0)} return _z_x})((dataMaps[dim])["values"]())):true?(((((tickStep ?? null) === null))?(tickStepMag = (((dim==='x'))?xMag:yMag), tickStep = (10**tickStepMag)):true?(tickStep = _z_.abs(_z_.number(tickStep)), (((((!Number.isFinite(tickStep))||((tickStep===0)))||((((dimMax-dimMin)/tickStep)>1000))))?((e => {throw e})(Error((dim+'TickStep is invalid or too small')))):void 0), tickStepMag = accuracy(tickStep)):void 0), t = roundToMagnitude(dimMin,tickStepMag,'up'), (() => {let _z_s; while (1) {(((t<=((dimMax+1e-14))))?(addTick(t), t = enforceRound((t+tickStep),tickStepMag)):true?((_z_s = 1, void 0)):void 0); if (_z_s) break}})()):void 0)):void 0), ((((!dimIsCat)&&(op((dim+'TickMax')))))?(addTick(dimMax)):void 0)):void 0)} return _z_x})(usedDims), getXAxisSpace = (function() {return space = op('xAxisPadding'), xAxis = op('xAxis'), (((xAxis||((op('axis')&&(((xAxis ?? null) === null))))))?(space += ((op('xAxisWidth')??(op('axisWidth')))/2)):void 0), ((ticks["x"]["length"])?(space += (op('xTickLength')??(op('tickLength'))), ((labels["x"]["length"])?(space += (op('xLabelPadding')+((op('xLabelFontSize')??(op('fontSize')))))):void 0)):void 0), space; var space,xAxis}), yAxisSpace = null, getYAxisSpace = (function() {return space = op('yAxisPadding'), yAxis = op('yAxis'), (((yAxis||((op('axis')&&(((yAxis ?? null) === null))))))?(space += ((op('yAxisWidth')??(op('axisWidth')))/2)):void 0), ((ticks["y"]["length"])?(space += (op('yTickLength')??(op('tickLength'))), ((labels["y"]["length"])?(ctx = getCanvasContext('yLabel'), space += (op('yLabelPadding')+(_z_.reduce((labels["y"]),(function(a,b,c) {return ((x, y) => y > x ? y : x)(a,(getTextWidth(ctx,b))); }),0)))):void 0)):void 0), yAxisSpace = space; var space,yAxis,ctx}), getTitle = (function(dim) {return title = op((dim+'Title')), (((((dim==='x')||((dim==='y')))&&(((title ?? null) === null))))?(vbleName = (_marks["0"])?.[dim], ((((typeof vbleName === 'string')&&(((vbleName["0"])==='~'))))?(title = vbleName["slice"](1)):void 0)):((title===false))?(title = null):void 0), title; var title,vbleName}), getTitleSpace = (function(dim) {return (((getTitle(dim) ?? null) === null)?0:((((op((dim+'TitleFontSize')))??(op('fontSize')))+(op((dim+'TitlePadding')))))); }), getSideSpace = (function(side) {return (((!yClean)&&((op('yAxisPosition')===side)))?(((yAxisSpace??(getYAxisSpace()))+(getTitleSpace('y')))):0); }), getTopSpace = (function() {return (((op('xAxisPosition')==='bottom')||xClean)?(getTitleSpace('plot')):((getXAxisSpace()+(getTitleSpace('x'))))); }), getBottomSpace = (function() {return (xClean?(0):((op('xAxisPosition')==='bottom'))?((getXAxisSpace()+(getTitleSpace('x')))):true?(getTitleSpace('plot')):void 0); }), paneSpaceOp = op('paneSpace'), [topSpace,rightSpace,bottomSpace,leftSpace,] = ((Array.isArray(paneSpaceOp)?paneSpaceOp:(_z_.empties(4)["fill"](paneSpaceOp)))), topSpace = topSpace ?? (getTopSpace()), rightSpace = rightSpace ?? (getSideSpace('right')), bottomSpace = bottomSpace ?? (getBottomSpace()), leftSpace = leftSpace ?? (getSideSpace('left')), plotSpace = fourOption(_options,'plotSpace'), paneHeight = op('paneHeight'), paneWidth = op('paneWidth'), ((((paneHeight ?? null) === null))?(height = op('height'), paneHeight = ((((height-(plotSpace["0"]))-topSpace)-bottomSpace)-(plotSpace["2"])), (((paneHeight<=0))?((e => {throw e})(Error('computed pane height is less than or equal to 0'))):void 0)):true?(height = ((((plotSpace["0"])+topSpace)+(plotSpace["2"]))+(((x, y) => y > x ? y : x)((paneHeight+bottomSpace),((legendOut?legendHeight:0)))))):void 0), ((((paneWidth ?? null) === null))?(width = op('width'), paneWidth = ((((width-(plotSpace["3"]))-leftSpace)-rightSpace)-(plotSpace["1"])), (((legendOut&&legendWidth))?(paneWidth -= (legendWidth+legendGap)):void 0), (((paneWidth<=0))?((e => {throw e})(Error('computed pane width is less than or equal to 0'))):void 0)):true?(width = (((((plotSpace["3"])+leftSpace)+paneWidth)+rightSpace)+(plotSpace["1"])), (((legendOut&&legendWidth))?(width += (legendWidth+legendGap)):void 0)):void 0), xScale = (function(a,b,c) {return (((a-xMin)/xRange)*paneWidth); }), yScale = (function(a,b,c) {return (-(((a-yMin)/yRange)*paneHeight)); }), ((op('_subplot'))?(container = _z_.$g()):true?(container = _z_.style(_z_.style(_z_.style(_z_.style(_z_.style(_z_.attr(_z_.$svg(),'viewBox',(((('0 0 '+width)+' ')+height))),'cursor','default'),'-moz-user-select','none'),'-webkit-user-select','none'),'-ms-user-select','none'),'user-select','none'), (((op('fit')!=='preserve'))?(_z_.attr(_z_.attr(container,'width',width),'height',height)):void 0)):void 0), ((opClass) => {return (((!((opClass ?? null) === null)))?(_z_.addClass(container,opClass)):void 0); })(op('class')), ((bgrd) => {return cornerRadius = op('cornerRadius'), (((!((cornerRadius ?? null) === null)))?(_z_.attr(bgrd,'rx',cornerRadius)):void 0); var cornerRadius})(setAttr(_z_.attr(_z_.attr(_z_.insert(container,(_z_.$rect())),'width',width),'height',height),'fill','background')), gPlot = _z_.insert(container,(_z_.$g())), (() => {return shift = (((legendPosition==='out-left')&&legendWidth)?((legendWidth+legendGap)):0), _z_.attr(gPlot,'transform',((((('translate('+(((plotSpace["3"])+shift)))+' ')+(plotSpace["0"]))+')'))); var shift})(), setAttr(setAttr(setAttr(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.insert(gPlot,(_z_.$rect())),'width',paneWidth),'height',paneHeight),'x',leftSpace),'y',topSpace),'fill','paneBackground'),'stroke-width','paneBorderWidth'),'stroke','paneBorderColor'), paneClipId = null, ((op('clip'))?(paneClipId = ('pane-clip-'+clipCount), clipCount += 1, _z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.insert(_z_.attr(_z_.insert(_z_.insert(gPlot,(_z_.$defs())),(_z_.$clipPath())),'id',paneClipId),(_z_.$rect())),'width',paneWidth),'height',paneHeight),'x',leftSpace),'y',topSpace)):void 0), (_z_x => {for (let dim of _z_x) {let dimGrid,gGrid; (((ticks[dim]["length"]))?(dimGrid = op((dim+'Grid')), (((dimGrid||((op('grid')&&(((dimGrid ?? null) === null))))))?(gGrid = _z_.attr(setDimAttr(setDimAttr(setDimAttr(_z_.insert(gPlot,(_z_.$g())),dim,'stroke-width','gridWidth'),dim,'stroke','gridColor'),dim,'stroke-opacity','gridOpacity'),'transform',((((('translate('+(leftSpace))+' ')+((topSpace+paneHeight)))+')'))), (_z_x => {for (let val of _z_x) {let x1,x2,y1,y2; (((dim==='x'))?(x1 = xScale(val), x2 = x1, y1 = 0, y2 = (-paneHeight)):true?(x1 = 0, x2 = paneWidth, y1 = yScale(val), y2 = y1):void 0), _z_.into(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.$line(),'x1',x1),'x2',x2),'y1',y1),'y2',y2),gGrid)} return _z_x})((ticks[dim]))):void 0)):void 0)} return _z_x})(usedDims), (_z_x => {for (let dim of _z_x) {let xDim,top,bottom,right,left,xAxisPadding,yAxisPadding,xShiftWrap,yShiftWrap,gWrap,axisUsed,halfAxisWidth,dimAxis,tickLength,labelPadding,labelRotate; xDim = (dim==='x'), top = (xDim&&((op('xAxisPosition')==='top'))), bottom = (xDim&&((!top))), right = ((!xDim)&&((op('yAxisPosition')==='right'))), left = (!(xDim||right)), xAxisPadding = op('xAxisPadding'), yAxisPadding = op('yAxisPadding'), xShiftWrap = (leftSpace+((right?((paneWidth+yAxisPadding)):((left?((-yAxisPadding)):0))))), yShiftWrap = (topSpace+((top?((-xAxisPadding)):((bottom?((paneHeight+xAxisPadding)):paneHeight))))), gWrap = _z_.attr(setFont(_z_.attr(_z_.attr(_z_.insert(gPlot,(_z_.$g())),'text-anchor',((xDim?(op('xLabelAlign')):((left?'end':'start'))))),'dominant-baseline',((xDim?((bottom?'hanging':'auto')):(op('yLabelAlign'))))),((dim+'Label'))),'transform',((((('translate('+xShiftWrap)+' ')+yShiftWrap)+')'))), axisUsed = false, halfAxisWidth = 0, dimAxis = op((dim+'Axis')), (((dimAxis||((op('axis')&&(((dimAxis ?? null) === null))))))?(axisUsed = true, ((line) => {return _z_.into(_z_.attr(setDimAttr(setDimAttr(setDimAttr(line,dim,'stroke-width','axisWidth'),dim,'stroke','axisColor'),dim,'stroke-opacity','axisOpacity'),((dim+'2')),((xDim?paneWidth:((-paneHeight))))),gWrap), halfAxisWidth = (_z_.attr(line,'stroke-width')/2); })(_z_.$line())):void 0), tickLength = (op((dim+'TickLength'))??(op('tickLength'))), labelPadding = op((dim+'LabelPadding')), labelRotate = op((dim+'LabelRotate')), (_z_x => {let _z_i = -1; for (let val of _z_x) {let i = ++_z_i; let gTick; gTick = _z_.attr(_z_.insert(gWrap,(_z_.$g())),'transform',(((dim==='x')?((((('translate('+(xScale(val)))+' ')+((top?((-halfAxisWidth)):halfAxisWidth)))+')')):((((('translate('+((left?((-halfAxisWidth)):halfAxisWidth)))+' ')+(yScale(val)))+')'))))), _z_.into(_z_.attr(setDimAttr(setDimAttr(setDimAttr(_z_.$line(),dim,'stroke-width','tickWidth'),dim,'stroke','tickColor'),dim,'stroke-opacity','tickOpacity'),((xDim?'y2':'x2')),(((bottom||right)?tickLength:((-tickLength))))),gTick), ((labels[dim]["length"])?((() => {return labelShift = (tickLength+labelPadding), labelOffset = op((dim+'LabelOffset')), lbl = _z_.attr(_z_.attr(_z_.text(_z_.$text(),(labels[dim][i])),((xDim?'y':'x')),(((bottom||right)?labelShift:((-labelShift))))),((xDim?'x':'y')),((xDim?labelOffset:((-labelOffset))))), (((!((labelRotate ?? null) === null)))?(center = labelShift, (xDim?(center += ((op((dim+'LabelFontSize'))??(op('fontSize')))/2)):void 0), _z_.attr(lbl,'transform',((xDim?((((('rotate('+labelRotate)+',0,')+((top?((-center)):center)))+')')):((((('rotate('+labelRotate)+',')+((left?((-center)):center)))+',0)')))))):void 0), _z_.into(lbl,gTick); var labelShift,labelOffset,lbl,center})()):void 0)} return _z_x})((ticks[dim])), (() => {return dimTitle = getTitle(dim), (((!((dimTitle ?? null) === null)))?((xDim?(x = op('xTitleOffset'), textAnchor = op('xTitleAlign'), (((textAnchor==='end'))?(x += paneWidth):((textAnchor!=='start'))?(x += (paneWidth/2), textAnchor = 'middle'):void 0), dominantBaseline = (bottom?'hanging':'auto'), y = (op('xTitlePadding')+halfAxisWidth), (((ticks[dim]["length"]))?(y += tickLength):void 0), (((labels[dim]["length"]))?(y += (labelPadding+((op('xLabelFontSize')??(op('fontSize')))))):void 0), (top?(y *= (-1)):void 0), rotate = null):true?(x = ((op('yTitlePadding')+((yAxisSpace??(getYAxisSpace()))))-(yAxisPadding)), (left?(x *= (-1)):void 0), textAnchor = op('yTitleAlign'), y = (((textAnchor==='start'))?(0):((textAnchor==='end'))?((-paneHeight)):true?((-(paneHeight/2))):void 0), dominantBaseline = (left?'auto':'hanging'), rotate = (((((('rotate('+((-90)))+' ')+x)+' ')+y)+')')):void 0), _z_.into(setFont(setUnlessNullish(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.text(_z_.$text(),dimTitle),'x',x),'y',y),'text-anchor',textAnchor),'dominant-baseline',dominantBaseline),'transform',rotate),((dim+'Title'))),gWrap)):void 0); var dimTitle,x,textAnchor,dominantBaseline,y,rotate})()} return _z_x})(usedDims), ((plotTitle) => {return (((!((plotTitle ?? null) === null)))?(top = ((op('xAxisPosition')==='bottom')||xClean), padding = op('plotTitlePadding'), align = op('plotTitleAlign'), _z_.into(setFont(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.text(_z_.$text(),plotTitle),'x',(((((align==='start'))?((leftSpace-((((op('yAxisPosition')==='left')&&((!yClean)))?((yAxisSpace??(getYAxisSpace()))):0)))):((align==='end'))?(((leftSpace+paneWidth)+((((op('yAxisPosition')==='right')&&((!yClean)))?((yAxisSpace??(getYAxisSpace()))):0)))):true?((((leftSpace+paneWidth)+rightSpace)/2)):void 0)+(op('plotTitleOffset'))))),'y',((top?((topSpace-padding)):(((topSpace+paneHeight)+padding))))),'text-anchor',align),'dominant-baseline',((top?'auto':'hanging'))),'plotTitle'),gPlot)):void 0); var top,padding,align})(getTitle('plot')), gMarks = setAttr(setAttr(setAttr(_z_.attr(_z_.insert(gPlot,(_z_.$g())),'font-size',((op('fontSize')+'px'))),'font-family','fontFamily'),'font-style','fontStyle'),'font-weight','fontWeight'), (paneClipId?(_z_.attr(gMarks,'clip-path',((('url(#'+paneClipId)+')')))):void 0), (_z_x => {for (let mk of _z_x) {let type,channels,xOffset,yOffset,size,nObs,presentInds,schemes,x,xx,y,yy,basic__tp__,xTransform,yTransform,colorTransform,textElm,addNote,w,h,pieData; ({type,} = mk), channels = markChannels["get"](mk), ({xOffset,yOffset,size,} = channels), nObs = markObs["get"](mk), presentInds = markPresentInds["get"](mk), schemes = markSchemes["get"](mk), x = (function(i) {return ((xScale(channels["x"](i))+leftSpace)+(xOffset(i))); }), xx = (function(i) {return ((xScale(channels["xx"](i))+leftSpace)+(xOffset(i))); }), y = (function(i) {return (((yScale(channels["y"](i))+topSpace)+paneHeight)-(yOffset(i))); }), yy = (function(i) {return (((yScale(channels["yy"](i))+topSpace)+paneHeight)-(yOffset(i))); }), basic__tp__ = (xTransform = (function(val) {return ((((!(typeof val === 'number'))&&(dataMaps["x"]["size"])))?(val = (dataMaps["x"])["get"](val)):void 0), ((xScale(val)+leftSpace)+(this["xOffset"])); }), yTransform = (function(val) {return ((((!(typeof val === 'number'))&&(dataMaps["y"]["size"])))?(val = (dataMaps["y"])["get"](val)):void 0), (((yScale(val)+topSpace)+paneHeight)-(this["yOffset"])); }), colorTransform = (function(val,fillOrStroke) {return dm = (dataMaps[fillOrStroke])["get"](mk), ((((!(typeof val === 'number'))&&(dm?.['size'])))?(val = dm["get"](val)):void 0), info = (schemes[fillOrStroke]), (((!info))?(val):(Array.isArray((info["scheme"])))?((info["scheme"][val])):true?(mn = info['min'], mx = info['max'], (info["scheme"])(((val-mn)/((mx-mn))))):void 0); var dm,info,mn,mx}), (function(elm,i) {return __tp__ = (((o,v1,v2,v3,v4) => {o.xTransform=v1;o.yTransform=v2;o.colorTransform=v3;o.type=v4;return o})(({"x":(x(i)),"y":(y(i)),"xOffset":(xOffset(i)),"yOffset":(yOffset(i)),}),xTransform,yTransform,colorTransform,type)), ((o,v1) => {o.__tp__=v1;return o})(elm,__tp__), __tp__; var __tp__})), textElm = (function(i,ti,xi,yi,defaultCenter) {return elm = setUnlessNullish(setUnlessNullish(setUnlessNullish(_z_.attr(_z_.attr(_z_.text(_z_.attr(_z_.attr(_z_.$text(),'x',xi),'y',yi),ti),'text-anchor',((defaultCenter?(((_options["hAlign"])??'middle')):(channels["hAlign"](i))))),'dominant-baseline',(channels["vAlign"](i))),'font-family',(channels["fontFamily"](i))),'font-style',(channels["fontStyle"](i))),'font-weight',(channels["fontWeight"](i))), fontSize = channels["fontSize"](i), (((!((fontSize ?? null) === null)))?(_z_.attr(elm,'font-size',((fontSize+'px')))):void 0), rot = channels["rotate"](i), (((!((rot ?? null) === null)))?(_z_.attr(elm,'transform',((((((('rotate('+rot)+',')+xi)+',')+yi)+')')))):void 0), elm; var elm,fontSize,rot}), addNote = (function(i,xi,yi,defaultCenter) {return ((channels["note"])?(ti = channels["note"](i), ((_z_.string(ti))?(xi += channels["noteXOffset"](i), yi -= channels["noteYOffset"](i), colorChannel = ((nc) => {return (((nc==='_fill')||((nc==='_stroke')))?(nc["slice"](1)):'noteColor'); })(channels["noteColor"]()), opacityChannel = ((nOp) => {return (((nOp==='_fillOpacity')||((nOp==='_strokeOpacity')))?(nOp["slice"](1)):'noteOpacity'); })(channels["noteOpacity"]()), finishNote(_z_.attr(_z_.attr(_z_.attr(_z_.insert(gMarks,(textElm(i,ti,xi,yi,defaultCenter))),'stroke','none'),'fill',(channels[(colorChannel)](i))),'fill-opacity',(channels[(opacityChannel)](i))),channels,i)):void 0)):void 0); var ti,colorChannel,opacityChannel}), (((type==='point'))?((() => {return areaScale = markAreaInfo["get"](mk)['scale'], (_z_x => {for (let i of _z_x) {let xi,yi,si,ai,elm,__tp__; xi = x(i), yi = y(i), si = channels["shape"](i), ai = areaScale(channels["area"](i)), elm = pointSymbol((({"shape":si,"area":ai,"x":xi,"y":yi,}))), ((mk["update"])?(__tp__ = basic__tp__(elm,i), (__tp__["area"]) = ai, (__tp__["areaTransform"]) = areaScale, (__tp__["shape"]) = si, (__tp__["shapeTransform"]) = (function(val) {return dm = (dataMaps["shape"])["get"](mk), ((((!(typeof val === 'number'))&&(dm?.['size'])))?(val = dm["get"](val)):void 0), (schemes["shape"]["scheme"][val]); var dm})):void 0), finishMark(_z_.insert(gMarks,elm),mk,channels,i), addNote(i,xi,yi)} return _z_x})(presentInds); var areaScale})()):((type==='segment'))?((_z_x => {for (let i of _z_x) {let xxi,yyi,elm; xxi = xx(i), yyi = yy(i), elm = _z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.$line(),'x1',(x(i))),'y1',(y(i))),'x2',xxi),'y2',yyi), ((mk["update"])?(basic__tp__(elm,i)):void 0), finishMark(_z_.insert(gMarks,elm),mk,channels,i), addNote(i,xxi,yyi)} return _z_x})(presentInds)):((type==='rect'))?(((mk["pixels"])?(w = (channels["width"]), h = (channels["height"])):true?(w = (function(i) {return ((channels["width"](i)/xRange)*paneWidth); }), h = (function(i) {return ((channels["height"](i)/yRange)*paneHeight); })):void 0), (_z_x => {for (let i of _z_x) {let xi,yi,wi,hi,xiLeft,yiTop,cxi,cyi,sp; xi = x(i), yi = y(i), wi = _z_.abs((+w(i))), hi = _z_.abs((+h(i))), ((mk["corner"])?(xiLeft = xi, yiTop = (yi-hi), cxi = (xi+((wi/2))), cyi = ((yi+yiTop)/2)):true?(xiLeft = (xi-((wi/2))), yiTop = (yi-((hi/2))), cxi = xi, cyi = yi):void 0), (((!(((mk["subplot"]) ?? null) === null)))?(sp = tp["option"]((({"width":wi,"height":hi,"_subplot":true,}))), mk["subplot"](sp,i,((channels["name"](i)??null))), finishMark(_z_.attr(_z_.insert(gMarks,(sp["plot"]())),'transform',((((('translate('+xiLeft)+' ')+yiTop)+')'))),mk,channels,i,'subplot')):true?(finishMark(setUnlessNullish(_z_.attr(_z_.attr(_z_.attr(_z_.attr(_z_.insert(gMarks,(_z_.$rect())),'x',xiLeft),'y',yiTop),'width',wi),'height',hi),'rx',(channels["cornerRadius"](i))),mk,channels,i), addNote(i,cxi,cyi)):void 0)} return _z_x})(presentInds)):((((type==='hLink'))||((type==='vLink'))))?((_z_x => {for (let i of _z_x) {let xxi,yyi,d; xxi = xx(i), yyi = yy(i), d = d3[(((type==='hLink')?'linkHorizontal':'linkVertical'))]()((({"source":([(x(i)),(y(i))]),"target":([xxi,yyi]),}))), finishMark(_z_.attr(_z_.insert(gMarks,(_z_.$path())),'d',d),mk,channels,i), addNote(i,xxi,yyi)} return _z_x})(presentInds)):((type==='edge'))?((_z_x => {for (let i of _z_x) {let xi,yi,xxi,yyi,ri,cwi; xi = x(i), yi = y(i), xxi = xx(i), yyi = yy(i), ri = ((_z_.sqrt(((((xi-xxi)**2))+(((yi-yyi)**2))))/2)/((size(i)**((1/3))))), cwi = _z_.number(_z_.boolean(channels["clockwise"](i))), finishMark(_z_.attr(_z_.insert(gMarks,(_z_.$path())),'d',(((((((((((((('M '+xi)+',')+yi)+' A ')+ri)+' ')+ri)+' 0 0 ')+cwi)+' ')+xxi)+',')+yyi))),mk,channels,i), addNote(i,xxi,yyi)} return _z_x})(presentInds)):((type==='text'))?((_z_x => {for (let i of _z_x) {let elm; elm = textElm(i,(channels['text'](i)),(x(i)),(y(i))), ((mk["update"])?(basic__tp__(elm,i)):void 0), finishMark(_z_.insert(gMarks,elm),mk,channels,i)} return _z_x})(presentInds)):((type==='arc'))?(((channels["pie"])?(pieData = d3["pie"]()["startAngle"]((channels["startAngle"]()))["endAngle"]((channels["endAngle"]()))["padAngle"]((channels["padAngle"]()))["sortValues"](((((((mk["pieSort"]) ?? null) === null))?null:(((mk["pieSort"])==='desc'))?(function(a,b,c) {return (b-a); }):(((mk["pieSort"])==='asc'))?(function(a,b,c) {return (a-b); }):(((typeof (mk["pieSort"]))==='function'))?(mk["pieSort"]):true?((e => {throw e})(Error('mark-arc, invalid pieSort option'))):void 0)))(((_z_x => {let _z_i = -1; let _z_m = []; for (let i of _z_x) {++_z_i; _z_m[_z_i] = (channels["pie"](i))} return _z_m})(presentInds)))):void 0), (_z_x => {let _z_i = -1; for (let i of _z_x) {let j = ++_z_i; let xi,yi,arcObj,cxi,cyi; xi = x(i), yi = y(i), arcObj = d3["arc"]()["innerRadius"]((channels["innerRadius"](i)))["outerRadius"]((channels["outerRadius"](i)))["padRadius"]((channels["padRadius"](i)))["cornerRadius"]((channels["cornerRadius"](i))), ((channels["pie"])?(arcObj["startAngle"]((pieData[j]["startAngle"]))["endAngle"]((pieData[j]["endAngle"]))["padAngle"]((pieData[j]["padAngle"]))):true?(arcObj["startAngle"]((channels["startAngle"](i)))["endAngle"]((channels["endAngle"](i)))["padAngle"]((channels["padAngle"](i)))):void 0), finishMark(_z_.attr(_z_.attr(_z_.insert(gMarks,(_z_.$path())),'d',(arcObj())),'transform',((((('translate('+xi)+' ')+yi)+')'))),mk,channels,i), [cxi,cyi,] = arcObj["centroid"](), addNote(i,((xi+cxi)),((yi+cyi)))} return _z_x})(presentInds)):(((type==='hBar')||((type==='vBar'))))?((_z_x => {for (let i of _z_x) {let xi,yi,nxi,nyi,si,yShift,xxi,yyi,xShift; xi = x(i), yi = y(i), nxi = xi, nyi = yi, si = size(i), (((type==='hBar'))?(yShift = (((si/yRange)*paneHeight)/2), xxi = xx(i), yyi = (yi-yShift), yi = (yi+yShift)):true?(xShift = (((si/xRange)*paneWidth)/2), yyi = yy(i), xxi = (xi+xShift), xi = (xi-xShift)):void 0), finishMark(_z_.attr(_z_.insert(gMarks,(_z_.$polygon())),'points',(((((((((((((((xi+',')+yi)+' ')+xxi)+',')+yi)+' ')+xxi)+',')+yyi)+' ')+xi)+',')+yyi))),mk,channels,i), addNote(i,nxi,nyi)} return _z_x})(presentInds)):true?((() => {return curveType = ((mk["curve"])??'linear'), (((!curveTypes["has"](curveType)))?((e => {throw e})(Error(((('mark-'+type)+', invalid curve type: ')+(mk["curve"]))))):void 0), lineFunc = ((((type==='line'))?(d3["line"]((function(a,b,c) {return x(a); }),(function(a,b,c) {return y(a); }))):((type==='hBand'))?(d3["area"]()["x"]((function(a,b,c) {return x(a); }))["y0"]((function(a,b,c) {return y(a); }))["y1"]((function(a,b,c) {return yy(a); }))):((type==='vBand'))?(d3["area"]()["x0"]((function(a,b,c) {return x(a); }))["x1"]((function(a,b,c) {return xx(a); }))["y"]((function(a,b,c) {return y(a); }))):void 0))["curve"]((d3[(('curve'+(capitalize(curveType))))])), dStr = (((((mk["missing"])==='gap'))?(lineFunc["defined"]((function(a,b,c) {return presentInds["has"](a); }))(((function(a,b,c) {return (function*(_z_l) {for (let _z_i = 0; _z_i < _z_l; _z_i++) {let i = _z_i; (yield i)}})(nObs); })()))):true?(lineFunc(presentInds)):void 0)), finishMark(_z_.attr(_z_.insert(gMarks,(_z_.$path())),'d',dStr),mk,channels), ((channels["note"])?(((((type==='line')&&((curveType["slice"](((-6)))==='Closed'))))?([cx,cy,] = polygonCentroid((_z_x => {let _z_i = -1; let _z_m = []; for (let i of _z_x) {++_z_i; _z_m[_z_i] = ([(x(i)),(y(i))])} return _z_m})(presentInds)), addNote(null,cx,cy,'defaultCenter')):true?(maxInd = _z_.max(presentInds), fxi = x(maxInd), fyi = y(maxInd), (((type==='line'))?(addNote(null,fxi,fyi)):((type==='hBand'))?(addNote(null,fxi,(((fyi+(yy(maxInd)))/2)))):true?(addNote(null,(((fxi+(xx(maxInd)))/2)),fyi)):void 0)):void 0)):void 0); var curveType,lineFunc,dStr,cx,cy,maxInd,fxi,fyi})()):void 0)} return _z_x})(_marks), (legendWidth?((() => {return (legendOut?(xPosn = ((legendPosition==='out-left')?(plotSpace["3"]):(((width-(plotSpace["1"]))-legendWidth))), yPosn = ((plotSpace["0"])+topSpace)):true?(xPosn = (((legendPosition["endsWith"]('left'))?((leftSpace+legendGap)):(legendPosition["endsWith"]('right'))?((((leftSpace+paneWidth)-legendGap)-legendWidth)):true?(((leftSpace+((paneWidth/2)))-((legendWidth/2)))):void 0)), yPosn = (((legendPosition["startsWith"]('top'))?((topSpace+legendGap)):(legendPosition["startsWith"]('bottom'))?((((topSpace+paneHeight)-legendGap)-legendHeight)):true?(((topSpace+((paneHeight/2)))-((legendHeight/2)))):void 0))):void 0), _z_.attr(gLegend,'transform',((((('translate('+xPosn)+' ')+yPosn)+')'))), _z_.insert((legendOut?container:gPlot),gLegend); var xPosn,yPosn})()):void 0), (target?((((typeof target)==='string')?(_z_.select(target)):target)["append"](container)):void 0), container):void 0); var _marks,_dataset,_options,op,setAttr,setDimAttr,setFont,getCanvasContext,channelData,dataMaps,limitsOp,xMinOp,xMaxOp,yMinOp,yMaxOp,xMin,xMax,yMin,yMax,xMinReqd,xMaxReqd,yMinReqd,yMaxReqd,markChannels,markObs,markSchemes,markAreaInfo,markPresentInds,gLegend,legendWidth,legendHeight,legendPosition,legendOut,legendGap,xMag,yMag,xRange,yRange,xClean,yClean,usedDims,ticks,labels,getXAxisSpace,yAxisSpace,getYAxisSpace,getTitle,getTitleSpace,getSideSpace,getTopSpace,getBottomSpace,paneSpaceOp,topSpace,rightSpace,bottomSpace,leftSpace,plotSpace,paneHeight,paneWidth,height,width,xScale,yScale,container,gPlot,paneClipId,gMarks}), tp["prototype"]['option'] = (function(newOptions) {return ((((newOptions ?? null) === null))?((this["_options"]) = ({})):true?(Object.assign((this["_options"]),newOptions)):void 0), this; }), tp["prototype"]['data'] = (function(d) {return ((this["_dataset"])?((e => {throw e})(Error('dataset already attached'))):void 0), checkArrayOfObjects(d), (this["_dataset"]) = d, this; }), tp["prototype"]['drop'] = (function(classes) {return (this["_marks"]) = ((classes?(classes = _z_.trim(classes)["split"](/\s+/), _z_.filter((this["_marks"]),((function(mark) {return ((mark['class'])?(markClasses = _z_.trim(mark['class'])["split"](/\s+/), (!_z_.intersection(markClasses,classes)['size'])):true?(true):void 0); var markClasses})))):true?([]):void 0)), this; }), tp["prototype"]['each'] = (function(d,f) {return checkArrayOfObjects(d), d["forEach"](f,this), this; }), (_z_x => {for (let name of _z_x) {tp["prototype"][name] = (function(...rest) {return ((((rest["length"])===0))?((e => {throw e})(Error('at least one argument expected'))):(((rest["length"])===1))?(options = (rest["0"])):true?([x,y,options,] = rest):void 0), (((!((options?.['data'] ?? null) === null)))?(checkArrayOfObjects((options["data"]))):void 0), mkObj = ({}), ((((rest["length"])>1))?(((o,v1,v2) => {o.x=v1;o.y=v2;return o})(mkObj,x,y)):void 0), Object.assign(mkObj,options), (mkObj["type"]) = name, (this["_marks"])["push"](mkObj), this; var options,x,y,mkObj})} return _z_x})(markNames), (_z_x => {for (let name of _z_x) {(tp[name]) = (function(...rest) {return po = (new (tp)()), (po[name])['apply'](po,rest), po; var po})} return _z_x})(_z_.array(markNames,'option','data','drop','each')), (tp["stack"]) = (function(data,ops={}) {return ({level,groupBy,stack,} = ops), offset = ops.offset ?? ('none'), ord = (ops['order']??'none'), missing = ops.missing ?? ('throw'), checkArrayOfObjects(data), ((((data["length"])===0))?((e => {throw e})(Error('empty data array'))):void 0), ((((((level ?? null) === null)||(((groupBy ?? null) === null)))||(((stack ?? null) === null))))?((e => {throw e})(Error('level, groupBy and stack options are required'))):void 0), (_z_x => {for (let d of _z_x) {(((((isInfOrNaN((d[level])))||(isInfOrNaN((d[groupBy]))))||(isInfOrNaN((d[stack])))))?((e => {throw e})(Error(nonFiniteMsg))):void 0)} return _z_x})(data), (((missing==='skip'))?(data = _z_.filter(data,((function(d) {return (!(((((d[level]) ?? null) === null)||((((d[groupBy]) ?? null) === null)))||((((d[stack]) ?? null) === null)))); }))), ((((data["length"])===0))?((e => {throw e})(Error(allMissingMsg))):void 0)):true?((_z_x => {for (let d of _z_x) {(((((d[level]) ?? null) === null))?((e => {throw e})(Error((('missing "'+level)+'" value')))):void 0), (((((d[groupBy]) ?? null) === null))?((e => {throw e})(Error((('missing "'+groupBy)+'" value')))):void 0), ((((((d[stack]) ?? null) === null)&&((missing!=='zero'))))?((e => {throw e})(Error((('missing "'+stack)+'" value')))):void 0)} return _z_x})(data)):void 0), groupNames = [], levelNames = _z_.array((new (Set)((_z_.pick(data,level))))), wideData = _z_.array(_z_.group(data,groupBy,((function(arr,gName) {return groupNames["push"](gName), ((((new (Set)((_z_.pick(arr,level))))['size']<(arr["length"])))?((e => {throw e})(Error((((('duplicate '+level)+'-')+groupBy)+' pair in data')))):void 0), obj = ({}), (_z_x => {for (let row of _z_x) {obj[(row[level])] = (row[stack])} return _z_x})(arr), obj; var obj})))["values"]()), validOrder = (new Set(['appearance','insideOut','none','reverse'])), validOffset = (new Set(['expand','diverging','none','silhouette','wiggle'])), levels = (_z_x => {let _z_i = -1; let _z_m = []; for (let row of _z_x) {let i = ++_z_i; _z_m[_z_i] = (({"name":(levelNames[i]),'lower':((_z_x => {let _z_i = -1; let _z_m = []; for (let pair of _z_x) {++_z_i; _z_m[_z_i] = ((pair["0"]))} return _z_m})(row)),'upper':((_z_x => {let _z_i = -1; let _z_m = []; for (let pair of _z_x) {++_z_i; _z_m[_z_i] = ((pair["1"]))} return _z_m})(row)),}))} return _z_m})(d3["stack"]()["keys"](levelNames)["value"]((function(a,b,c) {return ((a[b])??0); }))['order'](((((ord==='asc'))?(d3["stackOrderAscending"]):((ord==='desc'))?(d3["stackOrderDescending"]):(validOrder["has"](ord))?(d3[(('stackOrder'+(capitalize(ord))))]):true?((e => {throw e})(Error('invalid stack order'))):void 0)))["offset"]((((validOffset["has"](offset))?(d3[(('stackOffset'+(capitalize(offset))))]):true?((e => {throw e})(Error('invalid stack offset'))):void 0)))(wideData)), ((o,v1,v2) => {o.groupNames=v1;o.levels=v2;return o})(({}),groupNames,levels); var level,groupBy,stack,offset,ord,missing,groupNames,levelNames,wideData,validOrder,validOffset,levels}), (tp["lookup"]) = (function(data,key,returnMap) {return (returnMap?(mp = (new Map([])), (((typeof key === 'function'))?((_z_x => {let _z_i = -1; for (let d of _z_x) {let i = ++_z_i; mp["set"]((key(d,i,data)),d)} return _z_x})(data)):true?((_z_x => {for (let d of _z_x) {mp["set"]((d[key]),d)} return _z_x})(data)):void 0), mp):true?(obj = ({}), (((typeof key === 'function'))?((_z_x => {let _z_i = -1; for (let d of _z_x) {let i = ++_z_i; obj[(key(d,i,data))] = d} return _z_x})(data)):true?((_z_x => {for (let d of _z_x) {obj[(d[key])] = d} return _z_x})(data)):void 0), obj):void 0); var mp,obj}), (tp["update"]) = (function(elmts,pairs) {return (((typeof elmts === 'string'))?(elmts = _z_.selectAll(elmts)):((!elmts?.[(Symbol["iterator"])]))?(elmts = [elmts]):((!Array.isArray(elmts)))?(elmts = _z_.array(elmts)):void 0), ((((elmts["length"])===0))?((e => {throw e})(Error('must pass at least one element to update'))):void 0), ((_z_.some(elmts,(function(a,b,c) {return (!a["hasOwnProperty"]('__tp__')); })))?((e => {throw e})(Error('elements must be updateable mark elements'))):void 0), ({type,subtype,} = (elmts["0"]["__tp__"])), ((_z_.some(elmts,(function(a,b,c) {return (((a["__tp__"]["type"])!==type)||(((a["__tp__"]["subtype"])!==subtype))); })))?((e => {throw e})(Error('elements must have the same mark type (and subtype)'))):void 0), channels = (new (Set)((Object["keys"](pairs)))), (_z_x => {for (let ch of _z_x) {(((!channelNames["has"](ch)))?((e => {throw e})(Error((ch+' is not a channel')))):void 0), ((nonUpdateChannelNames["has"](ch))?((e => {throw e})(Error((ch+' channel cannot be updated')))):void 0), ((((type!=='text')&&((defChannels["get"](ch)['_kind']==='text'))))?((e => {throw e})(Error((('can only update '+ch)+' channel of text marks')))):void 0)} return _z_x})(channels), getVal = (function(elm,ch,i) {return val = (pairs[ch]), ((typeof val === 'function')?(val['call'](elm,(elm["__data__"]),i)):val); var val}), xUpdate = (function(elm,i) {return ((channels["has"]('x'))?((elm["__tp__"]["x"]) = (elm["__tp__"]["xTransform"])(getVal(elm,'x',i))):void 0), elm; }), yUpdate = (function(elm,i) {return ((channels["has"]('y'))?((elm["__tp__"]["y"]) = (elm["__tp__"]["yTransform"])(getVal(elm,'y',i))):void 0), elm; }), done = (function(...rest) {return (_z_x => {for (let ch of _z_x) {channels['delete'](ch)} return _z_x})(rest); }), (_z_x => {for (let ch of _z_x) {let _attr; _attr = defChannels["get"](ch)['_attr'], (_attr?(_z_.attr(elmts,(((_attr===true)?(camelToKebab(ch)):_attr)),(pairs[ch])), done(ch)):void 0)} return _z_x})(channels), (_z_x => {for (let ch of _z_x) {((channels["has"](ch))?((_z_x => {let _z_i = -1; for (let elm of _z_x) {let i = ++_z_i; _z_.attr(elm,ch,((elm["__tp__"]["colorTransform"])(getVal(elm,ch,i),ch)))} return _z_x})(elmts)):void 0)} return _z_x})(['fill','stroke']), done('fill','stroke'), (((type==='point'))?((_z_x => {let _z_i = -1; for (let elm of _z_x) {let i = ++_z_i; let __tp__; ({__tp__,} = elm), yUpdate(xUpdate(elm,i),i), ((channels["has"]('shape'))?((__tp__["shape"]) = (__tp__["shapeTransform"])(getVal(elm,'shape',i))):void 0), ((channels["has"]('area'))?((__tp__["area"]) = (__tp__["areaTransform"])(getVal(elm,'area',i))):void 0), pointSymbol(_z_.chg(_z_.at(__tp__,(['x','y','shape','area'])),'path',elm))} return _z_x})(elmts), done('shape','area')):((type==='text'))?((_z_x => {let _z_i = -1; for (let elm of _z_x) {let i = ++_z_i; let __tp__; ({__tp__,} = elm), yUpdate(xUpdate(elm,i),i), ((channels["has"]('x'))?(_z_.attr(elm,'x',(__tp__["x"]))):void 0), ((channels["has"]('y'))?(_z_.attr(elm,'y',(__tp__["y"]))):void 0), ((channels["has"]('fontSize'))?(_z_.attr(elm,'font-size',((getVal(elm,'fontSize',i)+'px')))):void 0), ((channels["has"]('text'))?(_z_.text(elm,(getVal(elm,'text',i)))):void 0), ((channels["has"]('rotate'))?(_z_.attr(elm,'transform',((((((('rotate('+(getVal(elm,'rotate',i)))+',')+(__tp__["x"]))+',')+(__tp__["y"]))+')')))):void 0)} return _z_x})(elmts), done('fontSize','text','rotate')):((type==='segment'))?((_z_x => {let _z_i = -1; for (let elm of _z_x) {let i = ++_z_i; let __tp__; ({__tp__,} = elm), yUpdate(xUpdate(elm,i),i), ((channels["has"]('x'))?(_z_.attr(elm,'x1',(__tp__["x"]))):void 0), ((channels["has"]('y'))?(_z_.attr(elm,'y1',(__tp__["y"]))):void 0), ((channels["has"]('xx'))?(_z_.attr(elm,'x2',((__tp__["xTransform"])(getVal(elm,'xx',i))))):void 0), ((channels["has"]('yy'))?(_z_.attr(elm,'y2',((__tp__["yTransform"])(getVal(elm,'yy',i))))):void 0)} return _z_x})(elmts), done('xx','yy')):void 0), done('x','y'); var type,subtype,channels,getVal,xUpdate,yUpdate,done}), (tp["cat"]) = (['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf']); var clipCount,gradientCount,markNames,singleMarkNames,channelNames,nonUpdateChannelNames,getKind,xyChannelNames,legendFillStrokeChannels,angleChannels,curveTypes,convenienceEvents,markChannelError,isInfOrNaN,nonFiniteMsg,allMissingMsg,capitalize,camelToKebab,minVal,maxVal,checkShapeScheme,checkArrayOfObjects,checkData,getChannelDefault,fourOption,populateDataMap,updateDataMap,setUnlessNullish,finishMark,finishNote,useColorScheme,equalTo,magnitude,magnitude10,roundToMagnitude,enforceRound,accuracy,getTextWidth,shapeDetails,pointSymbol,polygonCentroid,colorRamp,_z_;
})();
//# sourceMappingURL=index.js.map